\chapter[Introducción]{Introducción}
\label{cap:introduccion}

% Esqueleto de la intro general de la tesis
% Contexto: Explayarse sobre por qué los análisis de software son importantes. Meter énfasis en el testing y la verificación
% El análisis de software es una tarea crucial en el campo de la Ingeniería de
% Software \cite{}. Por ejemplo, la generación automática de tests \cite{} y la verificación \cite{} son muy efectivos para encontrar defectos en el software.


En la actualidad, el software está presente en casi todos los aspectos de la vida diaria, desde sistemas críticos en la industria aeronáutica y en salud, hasta aplicaciones móviles de uso cotidiano \cite{} \pp{Libros de ingenieria de software} La evolución de la tecnología y su integración en nuestra sociedad han hecho que la calidad del software sea un factor clave en el desarrollo tecnológico. La ingeniería de software es una disciplina fundamental en el desarrollo y construcción de sistemas de software complejos y de alta calidad \cite{} \pp{Libros de ingenieria de software}. 
%A medida que la tecnología ha avanzado, el software se ha vuelto omnipresente en nuestra vida cotidiana. 
A medida que el software se vuelve ubicuo gracias a los rápidos avances en tecnología, garantizar la corrección funcional del software es más crucial que nunca. Sin embargo, a menudo sucede que el software desarrollado es defectuoso, lo que causa distintos tipos de inconvenientes a los usuarios finales.
Además, la creciente demanda de sistemas de software crítico ha llevado a la aparición de diversos desafíos y problemas en su desarrollo y mantenimiento.

Para abordar estos problemas, un área de investigación de creciente importancia es la del análisis automático de software, cuyo objetivo es la provisión de herramientas para asistir a los programadores en diversas tareas, entre las que se encuentra la identificación de defectos en el software. La generación automática de tests \cite{Ponzio:2016, Rosner15, Abad13, Galeotti:2010, Khalek:2011, Pasareanu:2010, Gligoric10, Tillmann:2008, Pacheco07}, los \emph{model checkers} para software \cite{Visser06, Visser05, Clarke:2004}, y los análisis estáticos \cite{Calcagno:2011, Itzhaky:2014}, entre otros, son enfoques destacados en esta línea de investigación.

Aunque estas técnicas implican en muchos casos análisis completamente automatizados, su aplicación suele requerir cierto esfuerzo por parte de los ingenieros de software. Los \emph{model checkers} para software dependen de la definición de \emph{drivers}, programas que permiten construir entradas para el código bajo análisis. De manera similar, en los enfoques de pruebas unitarias parametrizadas \cite{Tillmann:2010} es obligatorio un mecanismo para construir entradas. Algunas herramientas basadas en la ejecución simbólica requieren las llamadas "fábricas de objetos" para construir casos de prueba que incluyan entradas con tipos no primitivos \cite{Tillmann:2008}. Las técnicas automatizadas de generación de pruebas basadas en la API de un módulo pueden usarse para construir entradas de tipos no primitivos \cite{Pacheco07, Fraser11}, automatizando así los problemas de generación de entradas antes mencionados. Sin embargo, suelen presentar dificultades para generar un buen conjunto de entradas diversas para módulos que manipulan estructuras dinámicas complejas (almacenadas en el heap). Esto es aún más difícil para módulos con APIs ricas \cite{Ponzio:2018}. Muchos autores han abordado este problema definiendo diferentes enfoques para guiar la generación de pruebas y crear conjuntos más diversos de entradas \cite{Ponzio:2018, Ciupa:2008}.

En este trabajo, se proponen dos enfoques diferentes para abordar el problema de generar mejores entradas para módulos con estados dinámicos complejos. Por un lado, observamos que la selección de rutinas de la API de módulo, para alimentar una herramienta de generación de entradas y construir estructuras para el análisis de programas (drivers para model checking de software, entradas para tests unitarios, o para tests parametrizados, etc.), tiene un impacto crucial en el análisis. Por esta razón, definimos el concepto de \emph{métodos generadores de objetos} como un subconjunto \(B\) de métodos, extraídos de la API de un módulo \(M\), que pueden emplearse para crear cualquier entrada para \(M\) en un análisis automatizado de programas  (por ejemplo, un driver para model checking de software). 
Claramente, cuanto mayor sea el número de estructuras diferentes que se puedan crear con \(B\), mayores serán las posibilidades de encontrar errores en \(M\). Decimos que un conjunto de métodos generadores de objetos es suficiente si estos pueden usarse en combinación para construir todas las estructuras posibles de \(M\). Por lo tanto, los generadores de objetos suficientes son la mejor opción posible para encontrar errores. Cabe notar que \(B\) puede contener rutinas superfluas. Una rutina superflua \(s\) es aquella tal que los objetos del módulo pueden construirse usando las rutinas en $B - \{s\}$ (el ejemplo más simple son las rutinas que nunca cambian el estado de los objetos, también denominados métodos puros u observadores \cite{}). Llamamos \emph{minimal} a un conjunto de generadores de objetos \(B\) que no contiene rutinas superfluas. La minimalidad es importante porque proporcionar rutinas superfluas a una herramienta de análisis automático suele impactar negativamente en su eficiencia (la cantidad de formas posibles de combinar \(k\) rutinas usualmente aumenta exponencialmente con respecto a \(k\)). 

Identificar un conjunto suficiente y minimal de métodos generadores de objetos de forma manual requiere de un análisis minucioso de las rutinas disponibles y una comprensión profunda de la semántica del módulo. Esto es especialmente difícil para módulos con APIs ricas, donde hay muchas rutinas y mucha redundancia en la API. Para facilitar la tarea del desarrollador, en este trabajo se proponen distintos enfoques automáticos para identificar conjuntos suficientes y minimales de métodos generadores de objetos, con distintas características. Exploramos aquí el uso de un algoritmo evolutivo y de un algoritmo codicioso (basado en hill climbing), con diferentes funciones objetivo que utilizan técnicas de generación automáticas de test. Además de buscar generadores de objetos suficientes y minimales, nuestros enfoques también tienen en cuenta otras características de los métodos, como la cantidad y la complejidad de sus parámetros, de modo que se favorecen las rutinas “más simples” en la búsqueda. El objetivo es elegir métodos generadores que puedan ser utilizados de manera más fácil y eficiente en los análisis de programas.

Dado que el número de instancias de un módulo de software es potencialmente infinito,
% y los análisis de programas que abordamos también están limitados en cuanto al número de estructuras que pueden emplear, 
nuestros algoritmos se limitan a explorar conjunto acotado de estructuras para \(M\) \cite{Boyapati02} (por ejemplo, todas las instancias de una lista enlazada con hasta \(k\) nodos). El valor de la función objetivo para un conjunto de rutinas \(R\) se basa en el número de estructuras acotadas que se pueden generar utilizando combinaciones de estas rutinas, mediante técnicas automáticas de generación de tests. Experimentamos con dos formas distintas de computar la función objetivo, una se basa en una modificación de una herramienta de generación de casos de prueba aleatorios (Randoop \cite{ref24}) para generar la mayor cantidad posible de estructuras acotadas a partir de \(R\), permitiendo como máximo \(k\) objetos de cada tipo en las estructuras (por ejemplo, todas las instancias de listas enlazadas con hasta \(k\) nodos). \pp{Esto es así Cacho?} Otra se basa en una técnica eficiente de generación exhaustiva acotada basada en la API, denominada BEAPI, que definimos en este trabajo (ver más adelante).
Nuestra evaluación experimental muestra que usando cotas razonables, los algoritmos definidos son eficientes, y computan métodos generadores de objetos suficientes y minimales con precisión (siempre computan generadores de objetos suficientes, y en la mayoría de los casos los generadores de objetos identificados son minimales, o tienen muy pocos métodos superfluos).


% TODO: Introducir BEAPI






% TODO: Evaluación experimental de builders
Evaluamos nuestro enfoque experimentalmente en un conjunto de clases Java con estados complejos, extraídas de la literatura. Los resultados muestran que, en nuestros casos de estudio, nuestro enfoque identifica conjuntos de rutinas que son suficientes y mínimos, en un tiempo aceptable \pp{Cuánto en promedio?}. También evaluamos el impacto de nuestro enfoque en un análisis automatizado, concretamente, en la generación de casos de prueba para pruebas parametrizadas \pp{No hicimos esto según entiendo}. Comparamos cómo se comporta la herramienta de generación de casos de prueba aleatorios Randoop cuando se le proporciona la API completa del módulo, frente a proporcionarle únicamente los constructores identificados por nuestro enfoque. Los resultados indican que, en este último caso, Randoop generó más objetos (y más grandes), dentro de un tiempo límite fijo.


% TODO: Evaluación experimental de BEAPI


% Contribuciones:
% 1- Definición y cómputo automático de builders

% Cuales son los análisis que se podrían beneficiar de los builders y por qué

% Definición intuitiva de builders
% Introducción de cómputo automático de builders

% 2- BEAPI
% Importancia de técnicas exhaustivas acotadas

% Por que me conviene generar a partir de la API

% Descripción breve de la técnica


% Breve resumen de los resultados
