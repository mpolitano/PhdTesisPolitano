\chapter[Trabajos Relacionados]{Trabajos Relacionados}
\label{cap:related-work}

Como se ha mencionado a lo largo de esta tesis, el problema de identificar un conjunto suficiente de métodos generadores de objetos 
para un módulo dado aparece de forma recurrente en distintos análisis de
programas, incluyendo, la verificación de software usando \emph{model checking} y la generación automática de tests.
En trabajos como \cite{DBLP:conf/tacas/NoriRTT09,DBLP:conf/tacas/KhurshidPV03} en el contexto de verificación 
de software usando \emph{model checking}, y
\cite{Tillmann:2010,Tillmann:2008,paPacheco07,DBLP:conf/icse/BraioneDMP18}, en
el contexto de generación automática de casos de test, aparece el problema de 
identificar una parte de una API y proveerla para el análisis. En general, esta tarea se realiza de forma manual en los enfoques previos.

El uso de técnicas basadas en búsqueda para resolver problemas complejos de
ingeniería de software es una estrategia cada vez más popular, con aplicaciones
exitosas en generación automática de tests \cite{Fraser:2011}, reparación de programas 
\cite{DBLP:journals/tse/GouesNFW12}, entre otros. Hasta donde tenemos
conocimiento, nuestros algoritmos de identificación de métodos generadores de
objetos son una aplicación novedosa de técnicas basadas en búsqueda a un problema de ingeniería
de software.

Un enfoque relacionado, aunque centrado en un problema distinto, es el propuesto
por la técnica \textsf{SUSHI} 
\cite{DBLP:conf/icse/BraioneDMP18}. En este caso, se utiliza un algoritmo genético alimentado por condiciones de camino 
(\emph{path conditions}) generadas mediante ejecución simbólica, con el objetivo
de construir entradas que satisfagan las condiciones de camino (es decir, que
cubran el camino) utilizando únicamente la API del módulo
en cuestión. Este enfoque asume que la API o el subconjunto relevante de métodos
ya ha sido provisto, lo que contrasta con nuestra propuesta, que precisamente aborda el problema de identificar dicho subconjunto.

Nuestra técnica requiere de un mecanismo para identificar métodos
\emph{observadores}, que se resolvió en nuestro trabajo utilizando el análisis estático 
implementado en la herramienta \emph{Infer}. 
Si bien existen enfoques previos para identificar observadores (también
    denominados en la literatura como métodos \emph{puros}
\cite{Huang:2012,Salcianu:2005}), es importante destacar que el 
foco de nuestros algoritmos de búsqueda no está puesto en esa tarea, sino en la
identificación de un conjunto minimal y suficiente de métodos generadores de objetos.
Además, nuestro enfoque es independiente del mecanismo utilizado para
identificar métodos observadores, por lo que podría 
complementarse con otros trabajos previos que abordan específicamente esa problemática.

En esta tesis se mostró también que, una vez identificado automáticamente un
conjunto métodos generadores de objetos a partir de la API, es posible aplicar técnicas de generación 
exhaustiva acotada usando estos métodos (\textsf{BEAPI}), sin necesidad de que el desarrollador
proporcione manualmente especificaciones formales. Este paso de identificación
previa de métodos generadores es clave en nuestra 
propuesta, ya que incrementa significativamente la eficiencia, y la escalabilidad
respecto de los scopes, de la generación exhaustiva acotada. 

Los enfoques de generación exhaustiva acotada han demostrado ser efectivos para
alcanzar una alta cobertura de código y para encontrar errores en el software,
tal como se reporta en diversos trabajos previos
\cite{Marinov01,Khurshid01,Boyapati02,Sullivan04}. Un objetivo de esta tesis no es 
revisar nuevamente la efectividad de las técnicas exhaustivas acotadas, sino
presentar un enfoque que resulte sencillo de aplicar sobre software existente,
como lo es \texttt{BEAPI}, que no requiere 
la provisión manual de especificaciones formales que capturen las propiedades
que deben cumplir las estructuras.

Se han propuesto diferentes lenguajes para describir formalmente las
restricciones estructurales en la generación exhaustiva acotada, incluyendo la lógica relacional de Alloy (en el llamado 
estilo de especificación declarativo), utilizada por la herramienta
\textsf{TestEra} \cite{Marinov01}; y el código fuente en un lenguaje imperativo
(en el estilo denominado operacional), como en 
\textsf{Korat} \cite{Boyapati02}. Las especificaciones declarativas tienen la
ventaja de ser más concisas y más simples para quienes están familiarizados con
este tipo de lenguajes; sin embargo, 
un conocimiento profundo de los lenguajes declarativos no es algo común entre
los desarrolladores de software. El estilo operacional puede ser más extenso
pero, como las especificaciones y el código están escritos en el 
mismo lenguaje de programación, este estilo suele ser el preferido por quienes desarrollan software.

\textsf{UDITA} \cite{Gligoric10} y \textsf{HyTeK} \cite{Rosner14} proponen emplear una combinación de los estilos declarativo y operacional para escribir las 
especificaciones, dado que ciertas restricciones pueden ser más fáciles de expresar 
en un estilo que en el otro. Si las especificaciones provistas son precisas, ambos enfoques
pueden ser utilizados para la generación exhaustiva acotada. Sin embargo, para utilizarlos los desarrolladores deben 
estar familiarizados con ambos estilos de especificación, y dedicar el tiempo y
esfuerzo necesarios para escribir dichas especificaciones (a diferencia de
\texttt{BEAPI} que no requiere especificaciones adicionales).

Los \emph{model checkers} para software como \textsf{Java Pathfinder}
\cite{Visser05} (\textsf{JPF}) también pueden realizar una generación exhaustiva
acotada para el código bajo prueba, pero el usuario debe proporcionar manualmente un 
\emph{driver} para la generación: un programa que el \emph{model checker} pueda
utilizar para construir las estructuras de manera exhaustiva acotada, que luego
se pasan como entrada al sistema bajo análisis para ejercitarlo. 
Escribir este tipo de drivers a menudo implica invocar rutinas de la API en
combinación con operadores no determinísticos propios del model checker (como
\textsf{JPF}), por lo que 
el desarrollador debe familiarizarse con estos operadores y realizar el trabajo
manual adicional de escribir el driver para aplicar este enfoque.
Además, los model checkers como \textsf{JPF} usualmente se ejecutan sobre una máquina virtual personalizada en lugar de la máquina virtual estandar de Java (\textsf{JVM}), lo cual introduce una 
sobrecarga significativa en su ejecución comparado con enfoques que utilizan la
\textsf{JVM} estándar (como \textsf{BEAPI}). Los resultados de un estudio previo 
\cite{Siddiqui09} muestran que \textsf{JPF} es significativamente más lento que
\textsf{Korat} para realizar la generación exhaustiva acotada. En dicho estudio,
se observa experimentalmente que \textsf{Korat} es el enfoque más rápido y
escalable de generación exhaustiva acotada. Esto se explica en parte por su poda
eficaz del espacio de búsqueda, y la eliminación de estructuras isomorfas. 
En contraste, \textsf{BEAPI} no requiere una especificación formal adicional
(\texttt{repOK}) y opera exclusivamente mediante invocaciones a métodos de la API.

Una variante alternativa de generación exhaustiva consiste en generar todas las
entradas necesarias para cubrir todos los caminos posibles (acotados) de
la ejecución de un programa, en lugar de generar todas las entradas acotadas.
Esta es la idea detrás de la generación sistemática dinámica de tests (también llamada
concolic testing), una variante de la ejecución 
simbólica \cite{Godefroid18}. Este enfoque ha sido implementado en diversas herramientas \cite{Godefroid12,Godefroid05,Pham19,Christakis15}, y ha logrado 
generar suites con alta cobertura de código, detectar errores reales en
programas, y verificar propiedades específicas de los programas (como seguridad
de memoria).
\textsf{Kiasan} \cite{Deng06} y \textsf{FAJITA} \cite{Abad13} también son
enfoques de generación de tests de caja blanca, que requieren especificaciones 
formales de las propiedades que deben cumplir las entradas, y tienen como objetivo cubrir el código del sistema bajo test.

La técnica de linealización ha sido empleada previamente en diversos contextos,
diferentes al de la generación exhaustiva acotada. Por ejemplo, para eliminar
estructuras isomorfas en model checkers tradicionales \cite{Iosif02,Robby03}, y también 
en model checkers para software como \textsf{JPF} \cite{Visser06}. Un estudio
anterior experimentó con el uso de coincidencia de estados en \textsf{JPF}, y propuso varias técnicas 
para podar el espacio de búsqueda de entradas mediante linealización, tanto para
ejecución concreta como para ejecución simbólica \cite{Visser06}. 
Como se indicó previamente, la ejecución concreta en \textsf{JPF} requiere que el usuario proporcione un \emph{driver}, 
mientras que el enfoque simbólico busca cubrir caminos del sistema. En cambio, nuestro trabajo se enfoca en la 
generación exhaustiva acotada de entradas usando la API. 
La linealización también ha sido utilizada con éxito para la minimización de suites de tests \cite{Xie04}.


