!TEX root = main.tex
\chapter[Motivation]{motivation}
\label{cap:motivation}

Para ilustrar las dificultades de escribir especificaciones formales para la generación de estructuras exhaustiva acotadas, se considera el invariante de representación (conmunmente llamados \emph{repOK}) de la clase \emph{NodeCachingLinkedList} (NCL) de Apache, que se muestra en la Figura \ref{fig:NCL-repOK}. Este es un repOK del conjunto de pruebas \emph{ROOPS}. Las NCL se componen de una lista principal circular doblemente enlazada, utilizada para el almacenamiento de datos, y una caché de nodos previamente utilizados implementada como una lista enlazada simple. Los nodos eliminados de la lista principal se mueven a la caché, donde se guardan para su usoen el futuro. De esta manera, cuando se requiere un nodo para una operación de inserción, se reutiliza un nodo de la caché (si existe) en lugar de asignar un nuevo nodo. El objetivo es evitar la sobrecarga de recolección de basura para las aplicaciones que realizan una gran cantidad de inserciones y eliminaciones en la lista. El \emph{repOK} devuelve true si y solo si la estructura de entrada satisface las propiedades estructurales de NCL. Las líneas 1 a 20 verifican que la lista principal sea una lista circular doblemente enlazada con una cabeza ficticia; las líneas 21 a 33 verifican que la caché sea una lista enlazada simple terminada en nulo (y se verifica la consistencia de los campos de tamaño en el proceso). Se observa que repOK está escrito de la manera recomendada para el enfoque de generación de BE de Korat: devuelve false tan pronto como encuentra una violación de una propiedad prevista en la entrada actual. De lo contrario, devuelve true al final. Estos repOK permiten a Korat podar grandes porciones del espacio de búsqueda, lo que mejora en gran medida su eficiencia.


\begin{figure}[!thb]
\begin{lstlisting}
public boolean repOK() {
  if (this.header == null) return false;
  //  Missing constraint: the value of the sentinel node must be null  
  // if (this.header.value != null) return false;
  if (this.header.next == null) return false;
  if (this.header.previous == null) return false;
  if (this.cacheSize > this.maximumCacheSize) return false;
  if (this.size < 0) return false;
  int cyclicSize = 0;
  LinkedListNode n = this.header;
  do {
      cyclicSize++;
      if (n.previous == null) return false;
      if (n.previous.next != n) return false;
      if (n.next == null) return false;
      if (n.next.previous != n) return false;
      if (n != null) n = n.next;
  } while (n != this.header && n != null);
  if (n == null) return false;
  if (this.size != cyclicSize - 1) return false;
  int acyclicSize = 0;
  LinkedListNode m = this.firstCachedNode;
  Set visited = new HashSet();
  visited.add(this.firstCachedNode);
  while (m != null) {
      acyclicSize++;
      if (m.previous != null) return false;
      // Missing constraint: the value of cache nodes must be null
      // if (m.value != null) return false;
      m = m.next;
      if (!visited.add(m)) return false;
  }
  if (this.cacheSize != acyclicSize) return false;
  return true;
}
\end{lstlisting}
\caption{\texttt{NodeCachingLinkedList}'s \texttt{repOK} from \textsf{ROOPS}}
\label{fig:NCL-repOK}
\end{figure}

Este ejemplo muestra que escribir repOKs sólidos y precisos para la generación de BE es difícil y requiere tiempo. Ajustar de manera precisas los repOKs para mejorar el rendimiento de la generación de BE (por ejemplo, para Korat) es aún más difícil. La principal ventaja de BEAPI es que no requiere ninguna especificación para la generación de entradas de BE. Si las rutinas de API utilizadas para la generación son correctas, todas las estructuras generadas son válidas por construcción. Las especificaciones más débiles se pueden utilizar como oráculos para probar el SUT, como oráculos completamente automatizados que vienen "gratis" en el código como excepciones, violaciones de contratos específicos del lenguaje (por ejemplo, equals es una relación de equivalencia en Java), propiedades metamórficas (calculadas automáticamente) [7], afirmaciones proporcionadas por el usuario en pruebas basadas en propiedades [32], o cualquier combinación de estos.