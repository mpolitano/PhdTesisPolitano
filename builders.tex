\chapter[Builders Identification]{Builders Identification}
\label{cap:builders}

El análisis de software es una tarea crucial en el campo de la Ingeniería de Software, ya sea para generar tests para el software bajo test (SUT)  o para realizar verificación de modelos de software. Estos enfoques requieren que los programadores identifiquen manualmente un subconjunto de los métodos de un módulo con el fin de dirigir el análisis. En general, al analizar un módulo, los programadores seleccionan un subconjunto de sus métodos que serán considerados como constructores de objetos (\emph{builders}) para definir lo que se conoce como un controlador o "driver", que se utilizará para construir objetos automáticamente para el análisis, combinándolos de manera no determinista, aleatoria, etc. Esto requiere una inspección minuciosa del módulo y su API, ya que la exhaustividad relativa del análisis (omitir métodos importantes puede evitar sistemáticamente la generación de diferentes objetos) y su eficiencia (las diferentes combinaciones acotadas de métodos crecen de manera exponencial a medida que aumenta el número de métodos) se ven afectados por la selección.

En esta tesis, proponemos tres enfoques para seleccionar automáticamente un conjunto de constructores de objetos a partir de la API de un módulo, basados en un algoritmo evolutivo y un algoritmo greedy y un algoritmo basado en clases de equivalencias. Estos algoritmos favorecen conjuntos de métodos cuyas combinaciones conducen a la generación de conjuntos más grandes de objetos o a aquellos conjuntos que obtienen mejor cobertura de branch del SUT. Además, los algoritmos tienen en cuenta otras características de estos conjuntos de métodos, tratando de priorizar la selección de aquellos con menor cantidad de métodos y con más simples parámetros.

% Para evaluar experimentalmente nuestra propuesta, hemos realizado una evaluación en un conjunto de clases con estado de referencia, que representan casos de uso típicos. Los resultados muestran que nuestro enfoque puede identificar automáticamente conjuntos de constructores de objetos que son suficientes (se pueden utilizar para crear cualquier instancia del módulo) y mínimos (no contienen métodos superfluos), en un tiempo razonable.

% En resumen, en este trabajo abordamos el desafío de seleccionar automáticamente un conjunto óptimo de constructores de objetos a partir de la API de un módulo, con el objetivo de mejorar tanto la exhaustividad como la eficiencia del análisis de software. Nuestros resultados experimentales demuestran la viabilidad y efectividad de nuestra propuesta, lo que abre nuevas perspectivas para la automatización de la selección de constructores de objetos en el análisis de software.


\section{Motivacion}

\cacho{Change te order maybe. Explain in detalle en un solo lado}
\cacho{Los listing lo pongo como listing, como figure o como que para hacer referencia}

\begin{table}[H]
\center
{\scriptsize
\begin{tabular}{|l|l|l|l|}
\hline
No. &Return type & Method name & Obs? \\
\hline
    0 && NCL() & no \\
    1& & NCL(int) & no \\
    2&& NCL(Collection) & no \\
    3&boolean & add(Object) & no \\
    4&void&add(int,Object) & no \\
    5&boolean&addAll(Collection) & no\\
    6&boolean&addAll(int,Collection) & no \\
    7&boolean&addFirst(Object) & no \\
    8&boolean&addLast(Object) & no\\
    9&void&clear() & no\\
    10&boolean&contains(Object) & yes \\
    11&boolean&containsAll(Collection) & yes \\
    12&boolean&equals(Object) & yes \\
    13&Object&get(int) & yes\\
    14&Object&getFirst() &yes \\
    15&Object&getLast() & yes\\
    16&int&indexOf(Object) &yes\\
    17&boolean&isEmpty() & yes\\
    18&Iterator&iterator() & no\\
    19&int&lastIndexOf(Object) &yes \\
    20&ListIterator&listIterator() &no \\
    21&ListIterator&listIterator(int) & no\\
    22&Object&remove(int) &no\\
    23&boolean&remove(Object) & no \\
    24&boolean&removeAll(Collection) & no \\
    25&Object&removeFirst() &no\\
    26&Object&removeLast() &no\\
    27&boolean&retainAll(Collection) &no \\
    28&Object&set(int,Object) &no\\
    29&int&size() &yes\\
    30&List&subList(int,int) & no \\
    31&Object[]&toArray() & yes \\
    32&Object[]&toArray(Object[]) &yes\\
    33&String&toString() & yes \\
\hline
\end{tabular}
}
\caption{Apache's NodeCachingLinkedList API}
\label{tab:ncl-api}
\end{table} 
En esta sección, motivamos nuestro enfoque mediante un ejemplo práctico. La estructura de datos NodeCachingLinkedList (NCL) de Apache \cite{apache} consta de una lista doblemente enlazada circular principal que contiene los elementos de la colección y una lista secundaria simplemente enlazada que actúa como caché para los nodos que se han eliminado de la lista principal. Los nodos almacenados en la caché pueden ser reutilizados y añadidos de nuevo a la lista principal al insertar elementos en ella. Gracias a su caché, en las aplicaciones en las que las inserciones y eliminaciones de la lista son muy frecuentes, NCL puede reducir significativamente la sobrecarga necesaria para la asignación de memoria y la recolección de basura de los nodos. 
Como ilustración, la Figura~\ref{fig:ncl-instances} muestra las tres instancias de NCL que se pueden construir con exactamente dos nodos.
\\

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{NCL-instances.png}
    \caption{Three NodeCachingLinkedList instances with exactly two nodes}
    \label{fig:ncl-instances}
\end{figure}


NCL tiene una API muy completa, como se muestra en la Tabla~\ref{tab:ncl-api}. Sin embargo, para construir cualquier objeto de NCL factible, sólo se necesitan algunos métodos de la API. Por ejemplo, las combinaciones de los métodos en la Figura~\ref{fig:NCLbuilders}, cuando se instancian con los parámetros apropiados, se pueden utilizar para construir cualquier objeto de NCL (finito) deseado. Por lo tanto, los siguientes métodos:
\\
\begin{lstlisting}[numbers=none,label=fig:NCLbuilders, caption=Conjunto de metodos sufiente para NCL]
  (0)  NodeCachingLinkedList()
  (7)  addFirst(Object)
  (25) removeFirst()
\end{lstlisting}


 son un ejemplo de un conjunto suficiente de constructores. Hay que tener en cuenta que, después de utilizar el constructor, la lista principal de NCL se puede rellenar simplemente utilizando el método \texttt{addFirst}. Sin embargo, si queremos generar instancias en las que la caché no esté vacía, podemos hacerlo a través del método \texttt{removeFirst}, como sugiere el conjunto suficiente de constructores. Para la mayoría de los análisis automatizados, nos gustaría considerar tantos escenarios variables (entradas) como sea posible, de ahí la motivación para construir conjuntos suficientes de constructores. Además, los constructores del Listing~\ref{fig:NCLbuilders} también son mínimos, ya que la falta de alguno de ellos implicaría que algunos objetos de NCL ya no se pueden construir.

Hay que tener en cuenta que puede haber muchos conjuntos de constructores suficientes y mínimos. Por ejemplo, se pueden obtener constructores suficientes y mínimos reemplazando el método \texttt{addFirst} en la Listing~\ref{fig:NCLbuilders} por cualquier otra variante de \texttt{add} que se muestra en la Listing~\ref{fig:NCLadds}, ya que para cualquier manera de llenar la lista principal de NCL con \texttt{addFirst}, existe una forma diferente de construir el mismo objeto utilizando otra variante de \texttt{add} (quizás invocada con diferentes parámetros y cambiando el orden de ejecución).
\\
\begin{lstlisting}[numbers=none,label=fig:NCLadds, caption=Variantes del método 'Add' que puedo ser utilizado para rellanar la lista principal en NCL, captionpos=b, frame=tb , basicstyle=\scriptsize]
  (3) add(Object)
  (4) add(int,Object)
  (7) addFirst(Object)
  (8) addLast(Object)
\end{lstlisting}


También observamos que cuanto más simples sean los parámetros de una rutina, más fácil será utilizarla para generar entradas en el contexto de un análisis de programas. Por ejemplo, entre las alternativas de rutinas de añadir para NCL (Listing.~\ref{fig:NCLadds}), \texttt{add(int,Object)} recibe más parámetros que los otros tres métodos, por lo tanto es más difícil generar parámetros para ella al generar entradas. Esto hace que las otras tres alternativas sean preferidas sobre ella. Así, nuestro enfoque tiene en cuenta el número de parámetros y sus complejidades para seleccionar los constructores mejores posibles.

Muchos métodos en la tabla \ref{tab:ncl-api} están marcados como observadores (columna Obs?), lo que significa que no modifican los objetos en los que operan, ni son útiles para crear objetos no primitivos. Por lo tanto, los observadores siempre son superfluos y nunca deben incluirse en un conjunto de constructores mínimos. Nuestro enfoque intenta reconocerlos de antemano y descartarlos de la búsqueda para reducir significativamente el espacio de búsqueda.

Para concluir esta sección, destacamos que, cuando se alimentó con toda la API de NCL, nuestro enfoque identificó automáticamente el conjunto suficiente y mínimo de constructores para NCL que se muestra en la Listing \ref{fig:NCLbuilders}.

\section{Algortimos}
Para encontrar un conjunto suficiente de constructores a partir de una API de un programa, diseñamos tres algoritmos de búsqueda que se describen a continuación. El primero es una modificación de los algoritmos genéticos, el segundo es una variante de un algoritmo Hill Climbing clásico, y el tercero es un algoritmo de búsqueda de acuerdo a las clases de equivalencias de los subconjuntos
Los algoritmos genéticos \cite{Goldberg:1989} son algoritmos de búsqueda no exhaustivos guiados. \cite{Michalewicz:1996}
% basados en una estrategia de escalada de colinas \cite{Russell:2009}.
Durante esta sección explicaré en detalle cada algoritmo.

\cacho{Hago una introduccion de los algoritmos? }
% El espacio de búsqueda está compuesto por un conjunto generalmente muy grande de individuos (los candidatos), y el objetivo de la búsqueda es encontrar un individuo con las características buscadas. A diferencia de los algoritmos de búsqueda clásicos, los algoritmos genéticos mantienen un conjunto de individuos, llamado población, y la búsqueda avanza seleccionando iterativamente un número de individuos en la población, utilizando estos para evolución (construyendo nuevos individuos a partir de estos), y dejando algunos individuos fuera del conjunto completo (los "viejos" y los "nuevos"). La selección de individuos para la evolución de la población, así como la eliminación de individuos, están guiadas por una función de fitness, la cual tambien es utilizada para guiar la búsqueda. Esta función se aplica a los individuos, y su resultado es generalizable a la población también (por ejemplo, la fitness de la población se puede tomar como la fitness de su individuo "más apto"). Esta función captura las características deseadas en la búsqueda, y por lo tanto se puede utilizar como criterio de parada (por ejemplo, el algoritmo se detiene después de encontrar un individuo con una aptitud por encima de cierto umbral). Finalmente, los individuos a menudo se llaman cromosomas, y se representan como vectores de genes que capturan sus características. Esta idea está fuertemente relacionada con cómo se construyen nuevos individuos: al representar a los candidatos como vectores de características independientes, se pueden construir nuevos candidatos combinando parte de las características de un individuo con parte de las características de otro, o cambiando arbitrariamente una característica de un individuo dado. Estas dos formas de evolución se llaman cross-over y mutación, respectivamente, y son el mecanismo tradicional para construir nuevos candidatos a partir de los existentes en los algoritmos genéticos. Dare mas detalles de este algoritmo en la seccion {TODO!!!!}.

% El segundo algoritmo, basado en una estrategia de Hill CLimbing\cite{TODO, qué citar sobre hill climbing}, es un algoritmo de búsqueda local que se mueve continuamente hacia arriba (incrementando) hasta alcanzar la mejor solución. Este algoritmo finaliza cuando se alcanza la cima. Este algoritmo es una algoritmo Greedy(Perezoso) [TODO explicar] porque selecciona un buen estado vecino sin pensar en dónde ir a continuación. Comienza con un estado no óptimo y lo mejora hasta alcanzar una condición. El objetivo de este algoritmo es mejorar estados existentes hasta alcanzar estados óptimos (estados que no pueden ser mejorados aún más). Se utiliza una función heurística para lograr estos estados.

% La estrategia de Hill Climbing es una técnica de búsqueda local que se utiliza comúnmente en la optimización de funciones. El algoritmo comienza en un punto arbitrario en el espacio de búsqueda y se mueve hacia un vecino mejor en cada iteración, hasta que se alcanza un máximo local. El rendimiento de la escalada de colinas depende fuertemente de la elección del vecino y de la función heurística utilizada para evaluar los vecinos.

% En general, el Hill Climbing es adecuada para problemas en los que se puede definir una función de evaluación localmente coherente y no es necesario explorar todo el espacio de búsqueda para encontrar una solución aceptable. Sin embargo, el algoritmo tiene dificultades para escapar de óptimos locales y puede quedarse atrapado en una solución subóptima. Por lo tanto, se utilizan variaciones del algoritmo, como Hill Climbing estocástico y la Hill Climbing con reinicio aleatorio, para superar estos problemas.
% Dare mas detalles de este algoritmo en la seccion {TODO!!!!}.


\subsection{Algoritmo Genético}
\label{alg:approachGA}
L


En mi trabajo, hemos utilizado una libreria muy utilizada en Java para algoritmos geneticos. Esta libreria se llama Jenetics (TODO:???) es una biblioteca de algoritmos genéticos de código abierto escrita en Java. Es ampliamente utilizada en la industria y en la academia para resolver problemas complejos de optimización y búsqueda.

%Pongo ejemplo de codigo???%

\emph{Jenetics} está diseñada para ser altamente personalizable y flexible, lo que permite a los usuarios definir sus propios problemas de optimización y personalizar los parámetros del algoritmo genético para obtener los mejores resultados posibles. La biblioteca proporciona una amplia gama de características, como diversos operadores genéticos, selección de población, variaciones de la población, y mucho más.
Una de las características más útiles de \emph{Jenetics} es su capacidad para trabajar con cualquier tipo de datos, incluyendo tipos de datos personalizados y clases. Esto hace que sea muy útil para resolver problemas en una amplia variedad de campos.

Además, \emph{Jenetics} es muy fácil de usar, con una documentación completa y una comunidad activa de usuarios que proporciona soporte y ayuda. 

En el contexto de nuestro problema, las soluciones candidatas representan conjuntos de métodos de la API del módulo que se está analizando. Luego, utilizamos vectores de valores booleanos como representación del cromosoma. Sea $n$ el número de métodos en la API; los cromosomas en nuestro algoritmo serán vectores de tamaño $n$. Para cualquier vector, la posición $i$ es verdadera si y solo si el cromosoma contiene el $i$-ésimo método de la API. Por ejemplo, hay 34 métodos en la API de NCL (Tabla \ref{tab:ncl-api}) y los enumeramos del 0 al 33. El conjunto suficiente de constructores en la Figura \ref{fig:NCLbuilders} se caracteriza por el vector con las posiciones 0, 7 y 25 establecidas como verdaderas, y las demás posiciones establecidas como falsas. Puede ver un ejemplo de esta represantacion aqui abajo:

\[
\begin{array}{|*{8}{c|}}
\hline
0 & 1 & \ldots  & 7 & \ldots  & 25  & \ldots  & 33 \\
\hline
1 & 0 & \ldots  & 1 & \ldots  & 1  & \ldots  & 0 \\
\hline
\end{array}
\]



\subsection{Hill Climbing}
\label{alg:approachHC}
El algoritmo Hill Climbing, también conocido como búsqueda por ascenso de colina. TODO??? , es un algoritmo de búsqueda local que se utiliza para optimizar una función de evaluación con respecto a una solución vecina. El objetivo del algoritmo es encontrar la solución óptima para un problema determinado, que se puede representar como un espacio de búsqueda con una función de evaluación asociada.

El algoritmo Hill Climbing comienza en una solución aleatoria y luego examina las soluciones vecinas para determinar si alguna de ellas es mejor que la solución actual. Si se encuentra una solución mejor, el algoritmo se mueve a esa solución y repite el proceso. Si no se encuentra una solución mejor, el algoritmo se detiene y devuelve la solución actual como la mejor solución.

El algoritmo Hill Climbing se puede utilizar para resolver una amplia variedad de problemas de optimización, como el problema del viajero, el problema de la mochila, etc. En cada uno de estos problemas, el objetivo es encontrar la solución óptima que minimice o maximice la función de evaluación.

El algoritmo Hill Climbing se puede implementar de diferentes maneras, dependiendo de la naturaleza del problema y de las restricciones del mismo. Una de las variantes más comunes es la búsqueda por ascenso de colina estocástico, que permite que el algoritmo acepte soluciones peores en algunos casos para evitar quedar atrapado en óptimos locales.

En el algoritmo Hill Climbing, los estados se representan como vectores de características, que se pueden modificar mediante operadores de mutación y operadores de cruce. El proceso de mutación implica cambiar una o más características de un estado aleatoriamente, mientras que el proceso de cruce implica combinar dos o más estados para generar un nuevo estado. Estos operadores se utilizan para generar nuevos estados y explorar el espacio de búsqueda de manera más efectiva.

En mi busqueda de algoritmo Hill Climbing es una técnica de búsqueda local que se utiliza para optimizar una función de evaluación en un espacio de búsqueda. El algoritmo se basa en la exploración de soluciones vecinas para encontrar la solución óptima. Se puede implementar de diferentes maneras y se utiliza en una amplia variedad de problemas de optimización.


Para mi trabajo doctoral, he modificado el algoritmo genetico para poder utilizar una fitness acorde al problema de encontrar subconjuntos optimos para la generacion de builders.
Esto lo hemos realizado en base.

\subsection{Clases de equivalencia}
\label{alg:approachCE}
\section{Fitness}
\subsection{BE}

\subsection{Random + Coverage}
