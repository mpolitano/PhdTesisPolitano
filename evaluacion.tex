%!TEX root = main.tex
\chapter[Evaluaci\'on]{Evaluaci\'on}
\label{cap:evaluation}

En los capítulos \ref{cap:beapi} y \ref{cap:builders} presentamos varios enfoques para mejorar la generación exhaustiva acotada:

\begin{itemize}
\item Identificación de métodos \emph{builders} para construir todos los objetos disponibles hasta una cota en una API. En este sentido, presentamos los siguientes algoritmos para encontrar estos métodos:
\begin{itemize}
\item Algoritmo Genético.
\item Algoritmo Greedy.
\item Algoritmo basado en clases de equivalencia.
\end{itemize}
\item Generación exhaustiva acotada a partir de métodos de la API.
\end{itemize}

En este capítulo, realizamos una evaluación experimental de estas técnicas con el objetivo de analizar la eficiencia y efectividad de las suites producidas en comparación con la generación exhaustiva acotada. En otras palabras, las siguientes preguntas de investigación guían esta experimentación:

\cacho{TODO: pensar mejor las RQ}
\begin{itemize}
\item \emph{RQ1}: ¿Qué tan efectivos son los algoritmos (Algoritmo Genético, Greedy, clases de equivalencia) para identificar conjuntos de métodos \emph{builders} y cuánto tiempo computacional requiere cada enfoque?
\item \emph{RQ2}: ¿Cuál es el impacto de utilizar métodos Builders identificados en comparación con el uso de todos los métodos de la API en la generación de estados mediante un verificador de modelos?
\item \emph{RQ3}: ¿Puede realizarse eficientemente la generación exhaustiva utilizando métodos de la API (BEAPI)?
\item\emph{RQ4}: ¿Cuál es el impacto de las optimizaciones propuestas en el rendimiento de BEG a partir de la API?
\item\emph{RQ5}: ¿Puede BEAPI ayudar a encontrar discrepancias entre las especificaciones repOK y la capacidad de generación de objetos de la API?
\item\emph{RQ6}: ¿Qué tan efectivas son las suites de prueba reducidas en comparación con la generación exhaustiva acotada?
\end{itemize}

\section{Algoritmos de Identificacion de metodos builders}

En esta sección, evaluamos experimentalmente nuestros enfoque para determinar que metodos son \emph{builders} a partir de una API. La evaluación se basa en un conjunto de implementaciones de estructuras de datos, que incluyen: \verb"NCL" de Apache Collections \cite{apache}; \verb"BinaryTree", \verb"BinomialHeap", \verb"FibonacciHeap", \verb"RedBlackTree" tomados de \cite{Visser:2006}; \verb"UnionFind", una implementación de conjuntos disjuntos tomada de JGrapht \cite{jgrapht}. También evaluamos nuestra técnica en componentes de proyectos de software reales, como \verb"Lits" de la implementación de Sat4j \cite{sat4j}, tomado de \cite{Loncaric:2018}, que consiste en un almacenamiento de variables que monitorea cuándo se hizo por última vez una suposición sobre el valor de una variable y si hay oyentes que están observando el estado de esa variable; \verb"Scheduler", una implementación de un planificador de procesos tomada de \cite{sir}; y estructuras de datos conocidas del paquete \verb"java.util" como: \verb"TreeMap", \verb"TreeSet", \verb"HashMap", \verb"HashSet" y \verb"LinkedList".

% Todos los experimentos se ejecutaron en máquinas Intel Core i7-6700 de cuatro núcleos a 3.4GHz, con 8GB de RAM, ejecutando GNU/Linux.

La primera evaluación consiste en ejecutar nuestros enfoques (Algoritmo \ref{alg:approachGA}, Algoritmo \ref{alg:approachHC}, Algoritmo \ref{alg:approachCE}) en las API de los módulos completos de las clases mencionadas anteriormente, para calcular conjuntos de métodos \emph{builders} para cada caso de estudio. El objetivo es evaluar qué tan buenos son los \emph{builders} identificados y el tiempo que cada enfoque tarda en calcularlos. Para cada caso de estudio, ejecutamos nuestro enfoque 5 veces. Los resultados se muestran en la Tabla \ref{tab:results-compute-bld}, que incluye el número de rutinas en la API completa (\#API), una muestra de los \emph{builders} identificados (algunos métodos pueden intercambiarse en diferentes ejecuciones, por ejemplo, \texttt{addFirst} y \texttt{addLast} en NCL) y el tiempo promedio de ejecución (en segundos) de las 5 ejecuciones. Inspeccionamos manualmente los resultados y encontramos que los conjuntos de métodos \emph{builders} identificados automáticamente fueron en todos los casos suficientes (todos los objetos factibles para la estructura se pueden construir utilizando los \emph{builders}) y mínimos (no contienen métodos superfluos).

Como muestran nuestros experimentos, nuestro algoritmo de \textit{Hill Climbing} es más efectivo que el \textit{Genetic Algorithm} para calcular los métodos \emph{builders} en todos los casos de estudio considerados. El enfoque de \textit{Hill Climbing} es razonablemente eficiente, tardando aproximadamente 5 minutos en el peor de los casos, mientras que el \textit{Genetic Algorithm} tarda 10 minutos en el peor de los casos. Esto se debe a que los algoritmos de Hill Climbing comienzan desde abajo hacia arriba (con menos métodos hacia más métodos), a diferencia de los algoritmos genéticos que generan sus sucesores mediante cruces o mutaciones. Debido a esto, el primer algoritmo tiene ventaja para encontrar los métodos mínimos en tiempos mejores. Es importante aclarar que puede haber casos de estudio no considerados en este trabajo donde el algoritmo genético se comporte mejor que el algoritmo de Hill Climbing. Esto ocurriría si la clase bajo prueba tiene pocos métodos, lo que hace que nuestro algoritmo evolutivo converja más rápido que el algoritmo de Hill Climbing (como TreeMap de BinTree en \cite{Visser:2006}). Es importante destacar que ambos enfoques encontraron el mismo conjunto de métodos \emph{builders}.


\begin{table}[t!]
\centering

{\small
\begin{tabular}{l l ccc}
\hline
&Sample Builders &\multicolumn{2}{c}{Time} \\
&   & GA & Greedy & Sets \\
\hline
\multirow{2}{*}{\textbf{NCL}} 
 & NCLinkedList(int)& &\\
 & addFirst(Object) &   & \\
 {\scriptsize \#API: 34}& removeFirst() &435 &290  \\
\hline

\multirow{2}{*}{\textbf{UFind}} 
 & UnionFind()& &\\
 & addElement(int) &  &  \\
 {\scriptsize \#API: 9}& union(int,int) &  63&79\\
\hline

\multirow{2}{*}{\textbf{FHeap}} 
 & FibonacciHeap()& &\\
 & insert(int) &  72 & 54 \\
 {\scriptsize \#API: 7}& removeMin()&  &\\
\hline

\multirow{1}{*}{\textbf{RBT}} 
 &TreeMap() && \\
 {\scriptsize \#API: 8}& put(int) &  3 & 3 \\
 &remove(int) &   &  \\
\hline

\multirow{1}{*}{\textbf{BTree}} 
 & BinTree()&& \\
 {\scriptsize \#API: 7}&add(int) & 2 &2 \\
\hline

\multirow{1}{*}{\textbf{BHeap}} 
 & BinomialHeap()& &\\
 {\scriptsize \#API: 10}&insert(int) &44&31 \\
 &decreaseKeyValue(int,int)& &  \\
\hline

\multirow{5}{*}{\textbf{Lits}} 
 & Lits()& &\\
 & getFromPool(int) & &\\
 & satisfies(int) & 35   & 26 \\
 {\scriptsize \#API: 26}& setLevel(int,int)&&\\
 & setReason(int)& &\\
\hline

\multirow{3}{*}{\textbf{Sched.}} 
 & Schedule()&& \\
 & addProcess(int)&& \\
{\scriptsize \#API: 10} & blockProcess() &58& 47  \\
 & quantumExpire()&&  \\
  & finishProcess()&&  \\

\hline

\multirow{1}{*}{\textbf{LinkedList}} 
 & LinkedList()& &\\
 {\scriptsize \#API: 67}&  addFirst(Object) &109   &41 \\
 \hline

\multirow{2}{*}{\textbf{TreeMap}} 
 & TreeMap()& &\\
 & put(Object,Object) & 633 & 321 \\
{\scriptsize \#API: 61}&  remove(Object) & &\\
\hline

\multirow{2}{*}{\textbf{TreeSet}} 
 & TreeSet()& &\\
 & add(Object) &   & \\
{\scriptsize \#API: 34}&  remove(Object) (int) & 36 & 16\\
\hline

\multirow{1}{*}{\textbf{HashSet}} 
 & HashSet(int,float)& &\\
 {\scriptsize \#API: 31}&  add(Object) & 37  &16 \\
\hline

\multirow{1}{*}{\textbf{HashMap}} 
 & HashMap(int,float)& &\\
{\scriptsize \#API: 45}& put(Object,Object) &  633 &110 \\
\hline

\end{tabular}%
}

\caption{Builders computation results}
\label{tab:results-compute-bld}
\end{table}

\hspace{1cm}




\section{BEAPI}


En la segunda parte de la evaluación, analizamos qué tan útiles son los builders identificados en el contexto de un análisis de programas, específicamente en la generación automatizada de casos de prueba. Estos objetos pueden utilizarse, por ejemplo, como entradas en test parametrizados. Para los estudios de caso que proporcionan mecanismos para medir el tamaño de los objetos y compararlos por igualdad (es decir, los métodos size y equals de las estructuras de datos), generamos pruebas con Randoop utilizando todos los métodos disponibles en la API (API), y luego generamos pruebas con Randoop utilizando solo los métodos builders (BLD) identificados por nuestro enfoque en el experimento anterior (Tabla \ref{tab:results-compute-bld}). Luego comparamos el número de objetos diferentes (No. de Objs.) y el tamaño del objeto más grande (Max Obj. Size) generados por las pruebas generadas a partir de la API, en comparación con las pruebas generadas utilizando solo los métodos de BLD. Establecimos tres budget diferentes para la generación de pruebas: 60, 120 y 180 segundos (Budget). Los resultados se resumen en la Tabla \ref{tab:results-obj}. Los resultados muestran que, en el mismo presupuesto de pruebas, BLD genera en promedio un 500 porciento más de objetos que la API. En todos los casos, BLD también genera objetos significativamente más grandes que la API. A la luz de estos resultados, queda claro que la identificación automatizada de builders es beneficiosa para la generación automatizada de estructuras para clases con estado.

Además, comparamos las suites de pruebas generadas con Randoop midiendo la cobertura de ramas y líneas de código. Al igual que en el experimento anterior, la suite de pruebas utilizada para la comparación se generó a partir de los métodos builders (BLD) en comparación con el uso de todos los métodos disponibles de la API con un Randoop predeterminado. Establecimos cinco presupuestos diferentes para la generación de pruebas: 60, 120, 180, 300 y 600 segundos (Budget). Los resultados se resumen en la Tabla \ref{tab:results-coverage}.

Cabe destacar que la tabla \ref{tab:results-coverage} muestra que, para los casos que manipulan estructuras de datos complejas (por ejemplo, java.util.TreeMap), las pruebas generadas solo con los métodos BLD obtienen una mejor cobertura tanto en ramas como en líneas de código
.
\begin{table}[!thb]
\scriptsize
\centering
\caption{Tiempo de ejecución de BEAPI con diferentes configuración.}

\begin{tabular}{ l r | r | r | r | r  }
  \toprule
  \multicolumn{6}{c}{\textbf{ROOPS}} \\
  \midrule 
  \textbf{Class} & \textbf{S} & \textbf{SM/BLD} & \textbf{SM}  & \textbf{BLD} & \textbf{NoOPT}  \\
  \midrule
  AVL
  & 3& .02 & .04 & .34 & - \\ 
  & 4& .03 & .07 & 102.16 & - \\ 
  & 5& .05 & .11 & - & - \\ 
  & 13& 46.71 & 657.17 & - & - \\ 
  \midrule
  NCL
  & 3& .04 & 1.31 & 1.37 & 7.96 \\ 
  & 4& .10 & 9.59 & 52.17 & - \\ 
  & 5& .34 & 40.54 & - & - \\ 
  & 8& 769.63 & - & - &  -\\ 
  \midrule
  BinTree
  & 3& .02 & .04 & .23 & 33.84 \\ 
  & 4& .05 & .08 & 85.32 & - \\ 
  & 5& .11 & .16 & - & - \\ 
  & 12& 966.41 & 2281.42 & - & - \\ 
  \midrule
  LList
  & 3& .03 & .09 & .26 & - \\ 
  & 4& .07 & .48 & 115.27 & - \\ 
  & 5& .18 & 118.75 & - & - \\ 
  & 8& 295.94 & - & - & - \\ 
  \midrule
  RBT
  & 3& .04 & .04 & 39.11 & - \\ 
  & 4& .11 & .09 & - & - \\ 
  & 5& .22 & .14 & - & - \\ 
  & 12& 81.03 & 2379.44 & - & - \\ 
  \midrule
  FibHeap
  & 3& .04 & .09 & .94 & - \\ 
  & 4& .13 & .20 &  & - \\ 
  & 5& .70 & 1.13 &  & - \\ 
  & 7& 129.01 & 243.36 & - & - \\ 
  \midrule
  BinHeap
  & 3& .05 & .11 & 2.03 & 18.38 \\ 
  & 4& .09 & .34 & - & - \\ 
  & 5& .26 & .96 & - & - \\  
  & 8& 96.94 & 220.18 & - & - \\ 
  \bottomrule
\end{tabular}
\end{table}

\begin{table}[!thb]
\scriptsize

\centering
\begin{tabular}{ l r | r | r | r | r  }
  \toprule
  \multicolumn{6}{c}{\textbf{Real World}} \\
  \midrule 
  \textbf{Class} & \textbf{S} & \textbf{SM/BLD} & \textbf{SM}  & \textbf{BLD} & \textbf{NoOPT}  \\
  \midrule
  NCL
  & 3 & .10 & .47 & -  & -  \\
  & 4 & .41 & 3.48  &  - & -  \\
  & 5 & 3.33  &  - &  - & -  \\
  & 6 & 73.78 &  - &  - &  - \\
  \midrule
  TSet
  & 3 & .03 & .07 & 56.82 & - \\
  & 11  & 21.52 & 86.06 &  - & -  \\
  & 12  & 69.98 & 276.85  &  - & -  \\
  & 13  & 226.66  & 887.83  &  - & -  \\
    \midrule
  TMap
  & 3 & .11 & .25 & - & - \\
  & 4 & .75 & 2.36  &  - &  - \\
  & 5 & 15.97 & 57.64 &  - & -  \\
  & 6 & 839.87  & 2901.37 &  - &  - \\
  \midrule
  LList
  & 3 & .02 & .13 & .64 & - \\
  & 6 & .96 & 258.85  & -  &  - \\
  & 7 & 12.98 &  - &  - &  - \\
  & 8 & 286.21  & -  & -  & -  \\
  \midrule
  HMap
  & 3 & .10 & 11.49 & - & - \\
  & 4 & .55 & -  & -  & -  \\
  & 5 & 5.33  & -  &  - &  - \\
  & 6 & 119.87  &  - &  - &  - \\
  \bottomrule

\end{tabular}

\label{table:beapi}

\end{table}






\begin{table}[t!]
\centering
\scriptsize
\begin{tabular}{ c l c c}
\hline
Class & Budget &
\multicolumn{2}{c}{\textsf{No. of Objs}} \\
&& \tiny{\textbf{Builders}} & \tiny{\textbf{AllMethods}} \\
\hline
\multirow{3}{*}{\textbf{NCL}} 
&	60	&	6648	&	470	\\
&	120	&	9436	&	612	\\
&	180	&	11441	&	703	\\
\hline
\multirow{3}{*}{\textbf{UFind}} 
&	60	&	1033	&	372	\\
&	120	&	1342	&	483	\\
&	180	&	1534	&	555	\\
\hline
\multirow{3}{*}{\textbf{FibHeap}}
&	60	&	6541	&	1766	\\
&	120	&	9270	&	2347	\\
&	180	&	10923	&	2745	\\
\hline
\multirow{3}{*}{\textbf{RBT}}
&	60	&	2634	&	515	\\
&	120	&	3410	&	611	\\
&	180	&	3938	&	676	\\
\hline
\multirow{3}{*}{\textbf{BTree}}
&	60	&	2937	&	975	\\
&	120	&	3820	&	1196	\\
&	180	&	4367	&	1354	\\
\hline
\multirow{3}{*}{\textbf{BHeap}}
&	60	&	6455	&	971	\\
&	120	&	8665	&	1230	\\
&	180	&	10093	&	1401	\\
\hline
\multirow{3}{*}{\textbf{Lits}}
&	60	&	3968	&	3174	\\
&	120	&	5109	&	4142	\\
&	180	&	5848	&	4783	\\
\hline
\multirow{3}{*}{\textbf{Schedule}}
&	60	&	2176	&	2901	\\
&	120	&	2756	&	2901	\\
&	180	&	3140	&	3437	\\
\hline
\multirow{3}{*}{\textbf{LinkedList}} 
&	60	&	8121	&	790	\\
&	120	&	11503	&	1095	\\
&	180	&	13905	&	1323	\\
\hline
\multirow{3}{*}{\textbf{TreeMap}} 
&	60	&	2750	&	748	\\
&	120	&	3754	&	953	\\
&	180	&	4496	&	1107	\\
\hline\multirow{3}{*}{\textbf{TreeSet}}
&	60	&	1129	&	291	\\
&	120	&	1527	&	343	\\
&	180	&	1816	&	381	\\
\hline
\multirow{3}{*}{\textbf{HashSet}}
&	60	&	8208	&	1498	\\
&	120	&	11467	&	2008	\\
&	180	&	13548	&	2366	\\
\hline
\multirow{3}{*}{\textbf{HashMap}}
&	60	&	9581	&	2103	\\
&	120	&	13044	&	3173	\\
&	180	&	15514	&	3784	\\
\hline

\end{tabular}%

\caption{Evaluación del uso de los builders identificados (BLD) frente a toda la API (API) en la generación de casos de test.}
\label{tab:results-obj}
\end{table}