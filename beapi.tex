\chapter{Generacion Exhaustiva acotada desde API de los programas}


\label{cap:beapi}

En adelante, se presenta la técnica  desarrollada llamada BEAPI, que tiene como objetivo mejorar la generación exhaustiva acotada (BEG, por sus siglas en inglés, \emph{Bounded Exhaustive Generation}). Este capítulo está organizado de la siguiente manera: en la Sección \ref{sec:motivation}, se presenta un ejemplo que ilustra el problema que se aborda con la técnica propuesta, la cual se explica en la Sección \ref{sec:beapiTecnique}. Luego, en las Secciones \ref{sec:scope}, \ref{sec:stateMatching} y \ref{sec:builders}, se describen las optimizaciones implementadas en BEAPI.


\section[Motivation]{motivation}
\label{sec:motivating-example}

Para motivar las dificultades de escribir especificaciones formales para la generación de estructuras exhaustiva acotadas,  considére el invariante de representación (conmunmente llamados \emph{repOK}) de la clase \emph{NodeCachingLinkedList} (NCL) de Apache, que se muestra en la Figura \ref{fig:NCL-repOK}. Este es un repOK del benchmarks \emph{ROOPS}. Los NCL se componen de una lista principal circular doblemente enlazada, utilizada para el almacenamiento de datos, y una caché de nodos previamente utilizados implementada como una lista enlazada simple. Los nodos eliminados de la lista principal se mueven a la caché, donde se guardan para su uso en el futuro. De esta manera, cuando se requiere un nodo para una operación de inserción, se reutiliza un nodo de la caché (si existe) en lugar de asignar un nuevo nodo. El objetivo es evitar la sobrecarga de recolección de basura para las aplicaciones que realizan una gran cantidad de inserciones y eliminaciones en la lista. El \emph{repOK} devuelve true si y solo si la estructura de entrada satisface las propiedades estructurales de NCL \cite{Liskov00}. Las líneas 1 a 20 verifican que la lista principal sea una lista circular doblemente enlazada con una cabeza ficticia; las líneas 21 a 33 verifican que la caché sea una lista enlazada simple terminada en nulo (y se verifica la consistencia de los campos de tamaño en el proceso). Se observa que repOK está escrito de la manera recomendada por los autores del enfoque de generación exhaustiva de BE, \textsf{Korat} \cite{Boyapati02}. Este devuelve False tan pronto como encuentra una violación de una propiedad prevista en la entrada actual. De lo contrario, devuelve Verdadero al final. Estos repOK permiten a \textsf{Korat} podar grandes porciones del espacio de búsqueda, lo que mejora en gran medida su eficiencia.


\begin{figure}[!thb]
\begin{lstlisting}
public boolean repOK() {
  if (this.header == null) return false;
  //  Missing constraint: the value of the sentinel node
  // must be null  
  // if (this.header.value != null) return false;
  if (this.header.next == null) return false;
  if (this.header.previous == null) return false;
  if (this.cacheSize > this.maximumCacheSize) return false;
  if (this.size < 0) return false;
  int cyclicSize = 0;
  LinkedListNode n = this.header;
  do {
      cyclicSize++;
      if (n.previous == null) return false;
      if (n.previous.next != n) return false;
      if (n.next == null) return false;
      if (n.next.previous != n) return false;
      if (n != null) n = n.next;
  } while (n != this.header && n != null);
  if (n == null) return false;
  if (this.size != cyclicSize - 1) return false;
  int acyclicSize = 0;
  LinkedListNode m = this.firstCachedNode;
  Set visited = new HashSet();
  visited.add(this.firstCachedNode);
  while (m != null) {
      acyclicSize++;
      if (m.previous != null) return false;
      // Missing constraint: the value of cache nodes
      // must be null
      // if (m.value != null) return false;
      m = m.next;
      if (!visited.add(m)) return false;
  }
  if (this.cacheSize != acyclicSize) return false;
  return true;
}
\end{lstlisting}
\caption{\texttt{NodeCachingLinkedList}'s \texttt{repOK} from \textsf{ROOPS}}
\label{fig:NCL-repOK}
\end{figure}

Este ejemplo muestra que escribir \texttt{repOK}s sólidos y precisos para BEG es difícil y consume tiempo. Afinar los \texttt{repOK}s para mejorar el rendimiento de BEG (por ejemplo, para \textsf{Korat}) es aún más difícil. 


\section[BEAPI]{BEAPI}
\label{sec:beapiIntro}
La técnica propuesta, llamada \textsf{BEAPI} (Bounded Exhaustive from API), introduce un enfoque novedoso para la generación exhaustiva acotada. Este enfoque se basa en la realización de llamadas a las rutinas de la API del Software bajo test (SUT). Al igual que otros enfoques de generación de pruebas basados en API, \textsf{BEAPI} crea secuencias de llamadas a métodos de la API, conocidas como secuencias de test, y las ejecuta para generar estructuras.

A diferencia de los enfoques de generación basados en caja negra, \textsf{BEAPI} no requiere una especificación formal de las propiedades de las estructuras. En lugar de eso, el usuario lo único que debe proporcionar son los alcances para la generación, lo cual se aborda en detalle en la sección \ref{ref:scope}.

La generación exhaustiva de todas las secuencias de prueba factibles a partir de rutinas hasta una longitud máxima, conocida como generación por fuerza bruta, es un enfoque intrínsecamente combinatorio que consume una gran cantidad de recursos computacionales, incluso para alcances pequeños. Por lo tanto, \textsf{BEAPI} utiliza varias técnicas de poda que son cruciales para mejorar su eficiencia y permitir la escalabilidad a alcances más grandes.

En primer lugar, \textsf{BEAPI} ejecuta secuencias de prueba y descarta aquellas que producen excepciones que violan las reglas de uso de la API, como \emph{IllegalArgumentException} e \emph{IllegalStateException} en Java.

En segundo lugar, \textsf{BEAPI} implementa la técnica de coincidencia de estado, la cual descarta secuencias de métodos que generan estructuras que ya han sido creadas por secuencias de métodos exploradas previamente. Esta técnica se describe en detalle en la sección \ref{sec:state-matching}.

En tercer lugar, \textsf{BEAPI} utiliza un subconjunto de las rutinas de la API para crear las secuencias de prueba. Este subconjunto se identifica mediante un algoritmo de búsqueda greedy y una función de valoración que tiene en cuenta qué subconjunto permite crear la mayor cantidad de objetos utilizando \textsf{BEAPI} en el menor tiempo posible. Este proceso se detalla en el capítulo \ref{cap:builders}.

La principal ventaja de \textsf{BEAPI} es que requiere un esfuerzo mínimo de especificación para realizar la generación exhaustiva acotada (BEG). Si los métodos de la API utilizados en la generación son correctos, todas las estructuras generadas serán válidas para su construcción. El programador solo necesita asegurarse de que los métodos de la API lancen excepciones cuando se violen las reglas de uso, siguiendo un estilo de programación defensivo \cite{Liskov00}. En la mayoría de los casos, esto implica verificar condiciones muy simples en las entradas. Por ejemplo, en el ejemplo mencionado, el método para agregar un elemento a un \texttt{NCL} lanza una \texttt{IllegalArgumentException} cuando se llama con un elemento \texttt{null}, mientras que la implementación del método se encarga de cumplir con las demás propiedades del \texttt{NCL}.

\cacho{TODO: no se si agregar arbolitos de exploracion para explicarlos}
\\
\\
% \begin{tikzpicture}
%     [level 1/.style={sibling distance=27mm},
%    level 2/.style={sibling distance=25mm},
%    every node/.style={rectangle,draw,fill=white,minimum size=10mm,align=center,font=\tiny},
%    edge from parent/.style={draw}]
   
%   % Raíz
%   \node {n = new NCL()}
%     % Hijos
%     child {node {n = new NCL() \\
%                 n.add(int)}
%       child {node {n = new NCL() \\
%                     n.method()}}
%       child {node {n = new NCL() \\
%                     n.anotherMethod()}}
%     }
%    child {node {n = new NCL() \\
%                 n.addFirst()}}
%    child {node {n = new NCL() \\
%                 n.remove()}}
%     child {node {...}}
%     % child {node {Método N}};
% \end{tikzpicture}



\section{Scope}
\label{sec:scope}

\begin{figure}[t!]
\begin{lstlisting}[keywordstyle=\scriptsize\ttfamily]
max.objects=3
int.range=0:2
strings=str1,str2,str3
omit.fields=NCL.DEFAULT_MAXIMUM_CACHE_SIZE
\end{lstlisting}
\caption{\textsf{BEAPI}'s scope definition for \texttt{NCL} (max. nodes 3)}
\label{fig:NCL-fin-BEAPI}
\end{figure}

\textsf{BEAPI} explora el espacio de búsqueda de secuencias de prueba (acotadas) que se pueden formar mediante llamadas a la API de \texttt{NCL}. Por lo tanto, debemos proporcionar dominios de datos para los tipos primitivos utilizados en esas llamadas y establecer un límite en el tamaño máximo de las estructuras que deseamos generar a partir de esas llamadas de API.

A continuación se muestra un ejemplo de archivo de configuración que define los alcances de \textsf{BEAPI} para el estudio de caso de \texttt{NCL}:

\begin{figure}[h!]
    \centering
    \begin{verbatim}
max.objects = 3
int.range = 0, 2
str1 = "value1"
str2 = "value2"
str3 = "value3"
omit.fields = maxCacheSize, modCounts
    \end{verbatim}
    \caption{Archivo de configuración de \textsf{BEAPI} para el estudio de caso de \texttt{NCL}}
    \label{fig:NCL-fin-BEAPI}
\end{figure}

El parámetro \texttt{max.objects} especifica el número máximo de objetos diferentes (alcanzables desde la raíz) permitidos en una estructura. Las secuencias de prueba que crean una estructura con más objetos diferentes (de cualquier clase) que \texttt{max.objects} se descartarán, junto con la estructura actual. En nuestro ejemplo, esto implica que \textsf{BEAPI} no creará NCL con más de 3 nodos.

Además, debemos especificar los valores que \textsf{BEAPI} utilizará para invocar las rutinas de la API que toman parámetros de tipo primitivo. El parámetro \texttt{int.range} permite especificar un rango de enteros, que va desde 0 hasta 2 en la Figura~\ref{fig:NCL-fin-BEAPI}. También se pueden especificar dominios para otros tipos primitivos, como flotantes, dobles y cadenas, describiendo sus valores por extensión. Por ejemplo, en la figura se definen \texttt{str1}, \texttt{str2} y \texttt{str3} como los valores factibles para los parámetros de tipo \texttt{String}.

Además, podemos informar a \textsf{BEAPI} qué campos relevantes considerar para la canonización de la estructura o qué campos omitir (\texttt{omit.fields}). Esto permite al usuario controlar el proceso de coincidencia de estados. Por ejemplo,  la línea 4 haría que \textsf{BEAPI} omita el tamaño máximo predeterminado de la caché en la coincidencia de estados, que en nuestro ejemplo es una constante inicializada en 20 en el constructor de la clase. Además, esta linea omitirá el campo \emph{modCount} que hemos hablado en el capitulo de identificación de métodos builders. En algunos casos, omitir estos tipos de campos puede ser importante.

La configuración mostrada en la Figura~\ref{fig:NCL-fin-BEAPI} es suficiente para que \textsf{BEAPI} genere NCL con un máximo de 3 nodos, que contienen enteros del 0 al 2 como valores. Los archivos de configuración utilizados en nuestra sección experimental son similares a los mostrados aquí.


\section{State Matching}
\label{sec:state-matching}

En la generación de pruebas con \textsf{BEAPI} a menudo muchas secuencias de prueba producen la misma estructura, por ejemplo, insertar un elemento en una lista y luego eliminarlo. \textsf{BEAPI} asume que las ejecuciones de métodos son deterministas: cualquier ejecución de una rutina con las mismas entradas produce los mismos resultados. Observamos que, para cada estructura distinta s, solo necesitamos guardar la primera secuencia de prueba que genera \texttt{s} (y la estructura en sí). Todas las secuencias de prueba generadas posteriormente que también crean \texttt{s} pueden ser descartadas. Nótese que, como \textsf{BEAPI} trabaja extendiendo secuencias de prueba previamente generadas %(ver seccion TODO ????)
, si guardamos muchas secuencias de prueba para la misma estructura, todas estas secuencias tendrían que ser extendidas con nuevas rutinas en iteraciones posteriores de \textsf{BEAPI}, lo que resultaría en muchos cálculos innecesarios. Por lo tanto, implementamos la coincidencia de estados en \textsf{BEAPI} de la siguiente manera. Almacenamos todas las estructuras producidas hasta ahora por \textsf{BEAPI} en una forma canónica (ver más abajo). Después de ejecutar la última rutina \texttt{r(p$_1$,..,p$_k$)} de una nueva secuencia de prueba generada \texttt{T}, comprobamos si alguno de los parámetros de \texttt{r} tiene una estructura no vista antes (no almacenada). Si T no crea ninguna estructura nueva, se descarta. De lo contrario, \texttt{T} y las nuevas estructuras que genera son almacenadas por \textsf{BEAPI}.

Representamos las estructuras asignadas en el montículo como grafos etiquetados. Después de la ejecución de un método, un parámetro $p$  (de tipo no primitivo) contiene una referencia al objeto raíz $r$ de un montículo con raíz (es decir,  $p=r$), definido a continuación.

\begin{definition}
    Sea $O$ un conjunto de Objectos y $P$ un set de valores primitivos (incluido $null$). Sea $F$ blos campos de todos los objectos en $O$. 
    \begin{itemize}
        \item A \emph{heap} es un grafp etiquetado $H = \langle O,E\rangle$ con $E = \{(o,f,v) | o \in O, f \in F, v \in O \cup P\}$.
        \item Un \emph{heap con raíz} es un par $RH = \langle r, H\rangle$ donde
            $r \in O$, $H = \langle O,E\rangle$ es un heap, y para cada $v' \in O \cup P$, $v'$ es alcanzable desde $r$ a través de campos en $F$.
    \end{itemize}
\end{definition}

El caso especial $p=null$  se puede representar con un montículo con raíz con un nodo ficticio y un campo ficticio que apunta a null. En lenguajes como Java, cada objeto se identifica por la dirección de memoria donde se encuentra. Cambiar las direcciones de memoria donde se asignan los objetos no tiene efecto desde el punto de vista del programa, ya que el programador no tiene control sobre la representación de bajo nivel de la memoria (a diferencia de otros lenguajes como C). Los montículos obtenidos por permutaciones de las direcciones de memoria de sus objetos componentes se llaman \emph{heap isomorfos}. Evitamos la generación de \emph{heaps isomorfos} empleando una representación canónica para heaps \cite{Iosif02,Boyapati02}. Los heaps enraizados se pueden canonizar eficientemente mediante un enfoque llamado \emph{linearización} \cite{Iosif02,Xie04}, que transforma un heap enraizado en una secuencia única de valores. 

\cacho{Lo cambio a espanol?}
\bigbreak

\begin{figure}[!th]
\begin{lstlisting}
int[] linearize(O root, Heap<O, E> heap, int scope, 
Regex omitFields) {
  Map ids = new Map(); // maps nodes into their unique ids 
  return lin(root, heap, scope, ids, omitFields); 
}
int[] lin(O root, Heap<O, E> heap, int scope, Map ids, 
Regex omitFields) { 
  if (ids.containsKey(root))
    return singletonSequence(ids.get(root)); 
  if (ids.size() == scope) 
    throw new ScopeExceededException();
  int id = ids.size() + 1;
  ids.put(root, id);
  int[] seq = singletonSequence(id);
  Edge[] fields = 
            sortByField({ <root, f, o> in E }, omitFields); 
  foreach (<root, f, o> in fields) {
    if (isPrimitive(o)) 
      seq.add(uniqueRepresentation(o));
    else
      seq.append(lin(o, heap, scope, ids, omitFields));
  }
  return seq; 
}
\end{lstlisting}
\caption{Linearization algorithm}
\label{alg:linearization}
\end{figure}


Se muestra en la Figura~\ref{alg:linearization} una versión personalizada para \textsf{BEAPI} del algoritmo de linearización de  \cite{Xie04} .El mismo fue modificado para informar cuando los objetos exceden los alcances y para admitir la omisión de campos de objeto. \texttt{linearize} invoca a \texttt{lin} y  comienza un recorrido en profundidad heap desde la raíz (línea 3). \texttt{linearize} asigna identificadores de objeto diferentes a cada objeto visitado. Cuando se visita un objeto por primera vez, se le asigna un nuevo identificador único (líneas 10-11) y se crea una secuencia de un solo elemento, seq, con el identificador de objeto para representar el objeto (línea 12). \texttt{ids} almacena el mapeo entre los objetos y los identificadores de objeto únicos. Luego, los campos del objeto, ordenados en un orden predefinido (por ejemplo, por nombre), se recorren y se construye la linearización de cada valor de campo y se agrega a la secuencia que representa el objeto, seq (líneas 13-19). Si un campo almacena un valor primitivo (línea 15), se agrega una secuencia de un solo elemento que representa el valor a seq (línea 16). Si el campo hace referencia a un objeto, se realiza una llamada recursiva a \texttt{lin}  para transformarlo en una secuencia, que se agregará a seq (línea 18). Al final del bucle, \texttt{seq}  contiene la representación canónica de todo el heap que comienza en la \texttt{raíz} , y se devuelve por \texttt{lin} (línea 20). Cuando se encuentra un objeto ya visitado por una llamada recursiva, es decir, que ya tiene un identificador asignado en  \texttt{ids}, el algoritmo devuelve la secuencia de un solo elemento con el identificador único del objeto (líneas 6-7). Si hay más de \texttt{scope} objetos alcanzables desde el heap enraizado, \texttt{linearize} devuelve una excepción para informar que se han superado los alcances (líneas 9-10). \texttt{linearize} también toma como parámetro una expresión regular \texttt{omitFields}, que coincide con los nombres de los campos que deben ser omitidos durante la canonicación (ver Sección~TODO REF). Para omitir tales campos, implementamos \texttt{sortByField} (línea 13) de tal manera que no devuelve las aristas correspondientes a los campos cuyos nombres coinciden con \texttt{omitFields}. Este comportamiento es particular de nuestro enfoque, ya que la excepción será empleada por BEAPI para descartar secuencias de prueba que creen objetos más grandes de lo permitido por los alcances. Nótese que la linearización permite la comparación eficiente de objetos: dos objetos son iguales si y solo si sus secuencias correspondientes generadas por \texttt{linearize} son iguales.


\section{Uso de Builders en BEAPI}
\label{sec:builders}

Dado que las combinaciones factibles de métodos crecen de manera exponencial con el número de métodos, es crucial reducir la cantidad de métodos que \textsf{BEAPI} utiliza para producir secuencias de prueba. Para evitar este problema, utilizamos el enfoque de identificación automático de métodos \emph{builders} presentado en el capitulo anterior (Capitulo \ref{cap:builders}) para encontrar un subconjunto de métodos de la API que son suficientes para la generación de conjuntos de estructuras acotadas y exhaustivas. Para el propósito que necesitamos en \textsf{BEPAI} el enfoque  para identificar un subconjunto de builders suficientes de una API que se basa en un algoritmo Greedy, nos fue suficiente. Recordemos que tenemos otros dos enfoques, pero computacionalmente son mucho mas costoso. Aquí consideramos un enfoque más simple, el basado en \emph{hill climbing} (HC), que logra un mejor rendimiento. Es posible que HC sea menos preciso, ya que puede incluir algunos métodos en el conjunto resultante de builders que podrían no ser necesarios para producir un conjunto acotado y exhaustivo de estructuras. Sin embargo, HC funcionó muy bien y calculó de manera consistente conjuntos mínimos de builders en nuestros experimentos (verificamos que el conjunto de builders calculados por HC coincidía con el conjunto de builders identificados manualmente para cada estudio de caso). Nuestro objetivo aquí es evaluar el impacto de utilizar builders para BEG (generación exhaustiva acotada) a partir de una API. 
En este caso utilizamos la función de valoración que utiliza un generador exhaustivo para generar objetos de la API (ver \ref{sec:fitness})
Observa que el algoritmo Hill Climbing realiza muchas invocaciones a un generador exhaustivo para la identificación de métodos builders. La idea clave que hace posible la identificación de builders es que a menudo los builders identificados para un alcance relativamente pequeño son el mismo conjunto de métodos que se necesitan para crear estructuras de cualquier tamaño. En otras palabras, una vez que el alcance para la computación de builders es lo suficientemente grande, aumentar el alcance dará como resultado el mismo conjunto de builders. Este resultado se asemeja a la hipótesis del alcance pequeño para la detección de errores \cite{Andoni02} (y \emph{transcoping} \cite{Rosner13}). Un alcance de 5 fue suficiente para la computación de builders en todos nuestros estudios de caso (verificamos manualmente que los builders calculados fueran los correctos en todos los casos). Después de que los builders se identifican de manera eficiente utilizando un alcance pequeño, podemos ejecutar \textsf{BEAPI} con los builders identificados utilizando un alcance mayor, por ejemplo, para generar objetos más grandes y poner a prueba el SUT. En la mayoría de nuestros estudios de caso, los builders comprenden un constructor y un solo método para agregar elementos a la estructura. Sin embargo, nuestro enfoque automatizado de identificación de builders mostró que, para los árboles Rojo-Negro, también se requería un método de eliminación (para alcances mayores que 3), ya que existen árboles con una configuración de balance particular (coloreando en rojo y negro para los nodos) que no se pueden construir solo agregando elementos al árbol. En contraste, los árboles AVL, que también están balanceados, no requieren el método de eliminación como builder, solo con el constructor de la clase y una rutina de adicción son suficientes. Esto demuestra que la identificación de builders no es trivial de realizar manualmente.

\section{Algoritmo de BEAPI}
\label{sec:beapiTechnique}

A continuación se muestra un pseudocódigo de \textsf{BEAPI} en la Figura \ref{alg:beapi}. \textsf{BEAPI} toma como entradas una lista de métodos de una API,  \texttt{methods} (la API completa o los métodos \emph{builders} previamente identificados); el alcance de objetos para la generación, \texttt{scope}; una lista para crear valores de cada tipo primitivo proporcionado en la descripción del alcance, \texttt{primitives} (creados automáticamente a partir de opciones de configuración como \texttt{int.range}, \texttt{string}, etc., ver Figura~\ref{fig:NCL-fin-BEAPI}); y una expresión regular que coincide con los campos que se deben omitir en la canonicación de las estructuras, \texttt{omitFields}. Observa que se pueden pasar métodos de más de una clase en \texttt{methods} si se desean generar objetos para varias clases en la misma ejecución de \textsf{BEAPI}, por ejemplo, cuando los métodos de una clase toman objetos de otra clase como parámetros. La estructura de datos de tipo mapa, \texttt{currSeqs} de \textsf{BEAPI}  almacena, para cada tipo, la lista de secuencias de test que se sabe que generan estructuras del tipo correspondiente. \texttt{currSeqs} se inicia con todas las secuencias de tipos primitivos en \texttt{primitives} (líneas 2-3). En cada iteración del bucle principal (líneas 5-34), \textsf{BEAPI}  crea nuevas secuencias para cada método disponible \texttt{m} (línea 8), explorando exhaustivamente todas las posibilidades para crear secuencias de prueba utilizando \texttt{m} e inputs generados en iteraciones anteriores y almacenados en \texttt{currSeqs} (líneas 9-30). Las secuencias de prueba recién creadas que generan nuevas estructuras en la iteración actual se guardan en el mapa \texttt{newSeqs} (inicializado vacío en la línea 6); todas las secuencias generadas se agregan a currSeqs al final de la iteración (línea 33). Si no se producen nuevas estructuras en la iteración actual (\texttt{newStrs} es falso en la línea 32), el bucle principal de \textsf{BEAPI}  termina y se devuelve la lista de todas las secuencias en \texttt{currSeqs} (línea 35).


\begin{figure}[t!]
\cacho{cambio a espanol?}

\begin{lstlisting}[language=Java]
public BEAPI(List methods, int scope, Map<Type, 
    List<Seq>> primitives, Regex omitFields) {
    Map<Type, List<Seq>> currSeqs = new Map();
    currSeqs.addAll({ T->L | T->L in primitives });
    Set canonicalStrs = new Set();
    for (int it=0; true; it++) {
      Map<Type, List<Seq>> newSeqs = new Map();
      boolean newStrs = false;
      for (m(T1,...,Tn):Tr: methods) {
        Map<Type, List<Seq>> seqsT1 = 
            currSeqs.getSequencesForType(T1);
        ...
        Map<Type, List<Seq>> seqsTn = 
            currSeqs.getSequencesForType(Tn);
        for ((s1,...,sn): seqsT1 x ... x seqsTn) {
          Seq newSeq = createNewSeq(s1,...,sn,m);
          o1,...,on,or,failure,exception = execute(newSeq);
          if (failure) 
            throw new ExecutionFailedException(newSeq);
          if (exception) 
            continue;
          c1,...,cn,cr,outOfScope = 
            makeCanonical(o1,...,on,or,scope,omitFields);
          if (outOfScope) 
            continue;
          if (isReferenceType(T1) and 
            !canonicalStrs.contains(c1)) {
                canonicalStrs.add(c1);
                newSeqs.addSeqForType(T1, newSeq);
                newStrs = true;
          }
          ...
          if (isReferenceType(Tr) and 
            !canonicalStrs.contains(cr)) {
                canonicalStrs.add(cr);
                newSeqs.addSeqForType(Tr, newSeq);
                newStrs = true;
          }
        }
      }
      if (!newStrs) 
        break;
      currSeqs.addAll(newSeqs);
    }
    return currSeqs.getAllSeqsAsList();
}
\end{lstlisting}
\caption{\textsf{BEAPI} algorithm}
\label{alg:beapi}
\end{figure}

A continuación, comentaré los detalles del bucle for en las líneas 9-30. En primer lugar, se obtienen todas las secuencias que se pueden utilizar para construir entradas para \texttt{m} en \texttt{seqsT$_1$}, ..., \texttt{seqsT$_n$}. \textsf{BEAPI} explora cada tupla \texttt{(s$_1$}, ..., \texttt{s$_n$)} de entradas factibles para \texttt{m}. A continuación, se ejecuta \texttt{createNewSeq} (línea 13), que construye una nueva secuencia de prueba \texttt{newSeq} realizando la composición secuencial de las secuencias de prueba \texttt{s$_1$}, ..., \texttt{s$_n$} y la rutina \texttt{m}, y reemplazando los parámetros formales de \texttt{m} por las variables que crean los objetos requeridos en \texttt{s$_1$}, ..., \texttt{s$_n$}. Luego, se ejecuta \texttt{newSeq} (línea 14) y produce un fallo (\texttt{failure} se establece en verdadero), genera una excepción que representa un uso no válido de la API (\texttt{exception} se establece en verdadero) o su ejecución tiene éxito y crea nuevos objetos \texttt{o$_1$,$\ldots$,o$_n$,o$_r$}. En caso de fallo, se lanza una excepción y \texttt{newSeq} se presenta al usuario como evidencia del fallo (línea 15). Si se lanza un tipo diferente de excepción, \textsf{BEAPI} asume que corresponde a un mal uso de la API (ver más abajo), descarta la secuencia de prueba (línea 16) y continúa con la siguiente secuencia candidata. De lo contrario, la ejecución de \texttt{newSeq} genera nuevos objetos \texttt{o$_1$,$\ldots$,o$_n$,o$_r$} (o valores de tipos primitivos) que se canonizan mediante \texttt{makeCanonical} (línea 17) --ejecutando \texttt{linearize} de la Figura~\ref{alg:linearization} en cada estructura. Si alguna de las estructuras producidas por \texttt{newSeq} excede el ámbito, \texttt{makeCanonical} establece \texttt{outOfScope} en verdadero, \textsf{BEAPI} descarta \texttt{newSeq} y continúa con la siguiente (línea 18).
%Esto garantiza que \textsf{BEAPI} nunca crea objetos más grandes que el ámbito dado.
Si ninguna de las situaciones anteriores ocurre, \texttt{makeCanonical} devuelve versiones canónicas de \texttt{o$_1$,$\ldots$,o$_n$,o$_r$} en las variables \texttt{c$_1$,$\ldots$,c$_n$,c$_r$}, respectivamente. A continuación, \textsf{BEAPI} realiza una coincidencia de estado comprobando que la estructura canónica \texttt{c$_1$} sea de tipo de referencia y que no haya sido creada por ninguna secuencia de prueba anterior (línea 19). Observa que \texttt{canonicalStrs} almacena todas las estructuras ya visitadas. Si \texttt{c$_1$} es una nueva estructura, se agrega a \texttt{canonicalStrs} (línea 27) y se agrega la secuencia que crea \texttt{c$_1$}, \texttt{newSeq}, al conjunto de secuencias de prueba que producen estructuras de tipo \texttt{T$_1$} (\texttt{newSeqs} en la línea 27). Además, se establece \texttt{newStrs} en verdadero para indicar que al menos se ha creado un nuevo objeto en la iteración actual (línea 22). Este proceso se repite para los objetos canónicos \texttt{c$_2$,$\ldots$,c$_n$,c$_r$} (líneas 24-29).

\textsf{BEAPI} distingue los fallos del mal uso de la API en función del tipo de excepción (similarmente a las técnicas anteriores de generación de pruebas basadas en API \cite{Pacheco07}). Por ejemplo,\\
\texttt{IllegalArgumentException} y \texttt{IllegalStateException} corresponden a usos incorrectos de la API, y el resto de las excepciones se consideran fallos de manera predeterminada. La implementación de \textsf{BEAPI} permite al usuario seleccionar las excepciones que corresponden a fallos y aquellas que no, configurando los parámetros correspondientes. Como se mencionó en la Sección~\ref{sec:motivating-example}, \textsf{BEAPI} asume que los métodos de la API lanzan excepciones cuando no se pueden ejecutar con entradas inválidas. Sostenemos que esta es una práctica común, llamada programación defensiva \cite{Liskov00}, que todos los programadores deberían seguir, ya que resulta en un código más robusto y mejora las pruebas de software en general \cite{Ammann16} (además de ayudar a las herramientas de generación de pruebas automatizadas). También argumentamos en la Sección~\ref{sec:motivating-example} que el esfuerzo de especificación requerido para la programación defensiva es mucho menor que escribir \texttt{repOK}s precisos (y eficientes) para BEG, y esto era cierto después de inspeccionar manualmente el código fuente de nuestros casos de estudio. Por otro lado, ten en cuenta que \textsf{BEAPI} puede utilizar especificaciones formales para revelar errores en la API, por ejemplo, ejecutando \texttt{repOK} y comprobando que devuelve verdadero en cada objeto generado del tipo correspondiente (como en Randoop \cite{Pacheco07}). Sin embargo, las especificaciones utilizadas para encontrar errores no necesitan ser muy precisas (por ejemplo, el \texttt{repOK} subespecificado \texttt{NCL} de la Sección~\ref{sec:motivating-example} es válido para encontrar errores), ni estar escritas de una manera particular (como lo requiere \textsf{Korat}). \textsf{BEAPI} también puede utilizar otros tipos de especificaciones más débiles y más simples de escribir para revelar errores, como violaciones de contratos específicos del lenguaje (por ejemplo, \texttt{equals} es una relación de equivalencia en Java), propiedades metamórficas \cite{Chen19}, afirmaciones proporcionadas por el usuario (\texttt{assert}), etc.

Otra ventaja de \textsf{BEAPI} es que, para cada objeto generado, proporciona una secuencia de prueba que se puede ejecutar para crear el objeto. Esto contrasta con los enfoques basados en especificaciones (que generan un conjunto de objetos a partir de \texttt{repOK}). Encontrar una secuencia de invocaciones a métodos de la API que creen una estructura específica es un problema difícil en sí mismo, que puede ser bastante costoso computacionalmente \cite{Braione17} o requerir un esfuerzo significativo para realizarlo manualmente. Por lo tanto, a menudo los objetos generados por enfoques basados en especificaciones están "incrustados" cuando se utilizan para probar un SUT (por ejemplo, mediante el uso de reflexión en Java), lo que hace que las pruebas sean muy difíciles de entender y mantener, ya que dependen de los detalles de implementación de bajo nivel de las estructuras \cite{Braione17}.

