
\section{State matching}
\label{sec:state-matching}

En la generación de pruebas con \textsf{BEAPI}, a menudo hay muchas secuencias de pruebas que producen el mismo objeto. Por ejemplo, insertar y luego eliminar el mismo elemento en una colección resulta en muchos casos con exactamente la misma estructura antes de la inserción. Esto también puede ser cierto para otros elementos disponibles (por ejemplo, todos los enteros en el ámbito). \textsf{BEAPI} asume que las ejecuciones de rutinas son deterministas con respecto a sus entradas. Es decir, ejecutar la misma rutina con las mismas entradas resulta en exactamente las mismas salidas. Bajo esta suposición, se sigue que para generar un conjunto exhaustivo y acotado de estructuras, solo necesitamos guardar una secuencia de prueba para crear cada estructura diferente en el conjunto, y que todas las secuencias de prueba siguientes que generen la misma estructura pueden descartarse (siempre y cuando no generen ninguna otra estructura nueva). Si guardáramos muchas secuencias de prueba para la misma estructura, todas estas pruebas tendrían que extenderse con nuevas rutinas en las iteraciones posteriores del enfoque de \textsf{BEAPI}, lo que resultaría en muchos cálculos innecesarios.

Para evitar el problema anterior, realizamos un emparejamiento de estados en las estructuras creadas por cada nueva prueba. Almacenamos todas las estructuras producidas hasta ahora por \textsf{BEAPI}, y después de ejecutar la última rutina \texttt{r(p$_1$,..,p$_k$)} de cada prueba \texttt{T}, verificamos si alguno de los parámetros de \texttt{r} contiene una estructura no vista antes (aquí, asumimos que el receptor de un método está incluido en \texttt{p$_1$,..,p$_k$}). Si no se producen nuevas estructuras mediante \texttt{T}, entonces se descarta y no se considera para su posterior extensión en iteraciones posteriores. De lo contrario, \texttt{T} se almacena, ya que genera una nueva estructura que no se produjo antes, por lo que es útil para la generación del conjunto exhaustivo y acotado de estructuras que el proceso busca producir.

Para nuestro proceso de coincidencia de estados, consideramos las estructuras almacenadas en el montículo como grafos etiquetados.

\begin{definition}
Sea $O$ un conjunto de objetos, y $P$ un conjunto de valores primitivos (incluyendo $null$). Sea $F$ el conjunto de campos de todos los objetos en $O$. Un \emph{montículo} $H$ es un grafo etiquetado $H = \langle O,E\rangle$ con $E = \{(o,f,v) | o \in O, f \in F, v \in O \cup P\}$.
\end{definition}


Observe que los montículos referenciados por un parámetro $p$ después de la ejecución de un método (es decir, $p=r$ después de la ejecución) se pueden ver como montículos raíz, con raíz $r$. El caso especial donde $p=null$ se puede representar mediante un nodo ficticio con un campo ficticio que apunta a $null$, para convertirlo también en un montículo raíz.

% \begin{definition}
% Un \emph{montículo raíz} $RH$ es un par $RH = \langle r, H\rangle$, donde $r \in O$ y $H = \langle O,E\rangle$ es un montículo, tal que para cada $v' \in O \cup P$, $v'$ es alcanzable desde $r$ a través de campos en $F$.
% \end{definition}

% Vale la pena destacar que en lenguajes como "Java o C#, cada objeto es identificado por la dirección de memoria donde se encuentra ubicado. Si permutamos las direcciones de memoria de los objetos asignados, obtenemos asignaciones alternativas de objetos que constituyen exactamente la misma estructura concreta. Estos montones obtenidos por permutación se llaman \emph{montones isomórficos}. Dado que las direcciones de memoria de los nodos no son relevantes en lenguajes sin manipulación explícita de memoria (como Java o C#), una representación canónica de un montón nos permite evitar la generación de montones isomórficos \cite{Iosif02,Boyapati02,Xie04}.

Los heaps enraizados se pueden canonizar eficientemente mediante un enfoque llamado \emph{linearización} \cite{Iosif02,Xie04}. La linearización transforma un heap enraizado en una secuencia única que representa el heap. Tomamos prestado un pseudocódigo del algoritmo de linearización de \cite{Xie04}, con ligeras modificaciones para informar los casos en que un heap enraizado excede el ámbito. El algoritmo \texttt{linearize} se muestra en la figura~\ref{alg:linearization}. El algoritmo \texttt{linearize} comienza un recorrido en profundidad del heap desde la raíz (línea 4). Si se encuentra un objeto con un identificador ya establecido debido a bucles en el grafo, la recursión se detiene en ese nodo y el algoritmo devuelve la secuencia singleton con el identificador único del objeto (líneas 7-8). Si se alcanzan más de \texttt{scope} objetos desde el heap enraizado, \texttt{linearize} devuelve una excepción para informar que se han excedido los ámbitos (líneas 9-10). Este comportamiento es particular de nuestro enfoque, ya que la excepción será utilizada por \textsf{BEAPI} para descartar secuencias de prueba que crean objetos mayores de lo permitido por los ámbitos. Cada vez que se encuentra un nuevo objeto, se le asigna un identificador único nuevo (líneas 11-12) y se construye una secuencia singleton \texttt{seq} para el objeto con su identificador (línea 13). Luego, se recorren los campos del objeto, ordenados en un orden predefinido (por ejemplo, por nombre), y se construye la linearización de cada valor del campo y se agrega a \texttt{seq} (líneas 15-20). Si un campo almacena un valor primitivo (línea 16), se agrega una secuencia singleton que representa el valor al final de \texttt{seq} (línea 17). De lo contrario, el campo hace referencia a un objeto y se transformará recursivamente en una secuencia que se agregará al final de \texttt{seq} (línea 19). Al final del bucle, \texttt{seq} contiene la representación canónica de todo el heap enraizado y es devuelta por el algoritmo (línea 21).

Es importante destacar que la linearización permite una comparación eficiente de los montículos enraizados: dos montículos enraizados son iguales si y solo si sus secuencias correspondientes obtenidas por medio de \texttt{linearize} son iguales. Los campos que son considerados irrelevantes por el desarrollador pueden ser marcados para ser omitidos (ver la sección de alcance arriba). Para el caso de los campos omitidos (como en el ejemplo de la Figura~\ref{fig:NCL-fin-BEAPI}), hacemos que el algoritmo \texttt{linearize} no devuelva las aristas correspondientes a estos campos en el método \texttt{sortByField} (línea 14). Esto a su vez evita guardar los valores de estos campos en la secuencia generada por el algoritmo. Omitimos este caso de la Figura~\ref{alg:linearization} para simplificar la presentación

